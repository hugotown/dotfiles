# Project Rules & Guidelines

This file consolidates all development rules and guidelines for project, incorporating standards from multiple sources including general development principles, project-specific patterns, Context7 libraries, and the comprehensive project structure documentation.

## IMPORTANT: Documentation and File Management Policy

**No Documentation Files:** Do NOT generate explanatory files, guides, tutorials, or any standalone documentation files (README.md, GUIDE.md, etc.).

**Documentation Location:** All documentation must be added as **short, clear, and concise appendices** exclusively in this file (`.claude/CLAUDE.md`).

**Documentation Style:** ALL documentation in this file MUST be **extremely short, clear, and concise**. Avoid verbosity, redundancy, or unnecessary explanations. Get to the point immediately.

**Temporary Files:** Any temporary files generated during development or testing **MUST be deleted** immediately after use.

## 1. Communication and Language

**Primary Language:** All communication with AI assistants will be exclusively in **Spanish**.

**Code and Comments:**

- Generated code will always be in **English**.
- Comments within the code will also be in **English**, facilitating universal understanding and maintenance.

## 2. Software Development Principles

Excellence in development is paramount. Therefore, I strictly adhere to:

**SOLID Principles:** To create robust, maintainable, and scalable software.

- **S**ingle Responsibility Principle
- **O**pen/Closed Principle
- **L**iskov Substitution Principle
- **I**nterface Segregation Principle
- **D**ependency Inversion Principle

**DRY (Don't Repeat Yourself) Principle:** To avoid redundancy and improve code efficiency and maintainability.

**Test-Driven Development (TDD):** Writing tests before functional code to ensure quality and expected behavior from the outset.

## 3. Portable Configuration Philosophy

**Core Philosophy:** `~/.config/` is a **portable git repo** that works on any platform (nix-darwin, NixOS, Arch Linux) without modification. Nix is responsible for **installing** packages only. All user configuration lives in `~/.config/` and is **platform-agnostic**.

### Directory Structure

```
~/.config/                              # Git repo (portable)
  shell/
    env.fish, env.nu, env.zsh           # Portable env (PATH with platform detection)
    bashrc, zshrc, bash_profile         # Symlinked to ~/ by bootstrap.sh
    integrations/                       # Git-tracked (portable, rarely change)
      zoxide.{fish,nu,zsh,bash}
      atuin.{fish,nu,zsh,bash}
      yazi.{fish,nu,zsh,bash}
      cldy.{fish,nu}
      mise.{fish,nu,zsh,bash}
    bootstrap.sh                        # Generates ~/.cache/shell/ + symlinks dotfiles
  hosts/                                # Non-Nix platform setup scripts
    arch/initialize.sh                  # pacman packages + bootstrap + tools
    macos-brew/initialize.sh            # brew packages + bootstrap + tools + macOS setup
  fish/config.fish                      # Sources from shell/
  nushell/config.nu                     # Sources from shell/
  nushell/env.nu                        # Real file, sources shell/env.nu
  nixos/                                # Nix configuration ONLY (nix-darwin + NixOS)
    flake.nix, hosts/, lib/, secrets/

~/.cache/shell/                         # Ephemeral, NOT in git (absolute paths)
  starship.{fish,nu,zsh,bash}           # Generated by bootstrap.sh
  direnv.{fish,zsh,bash}                # Generated by bootstrap.sh
```

### Rules

**Rule 1: `~/.config/nixos/`** - Nix/NixOS/nix-darwin `.nix` files and SOPS secrets ONLY.

**Rule 2: `~/.config/<app>/`** - User-editable app configuration. No Nix-generated files.

**Rule 3: `~/.*` Dotfiles** - User-managed (`.zshrc`, `.bashrc`). No Nix-generated files.

**Rule 4: `~/.cache/shell/`** - Ephemeral files with absolute system paths. Generated by `bootstrap.sh`, not tracked in git.

### Shell Integration Architecture

**Tracked integrations** (`~/.config/shell/integrations/`): Output of tools like `zoxide init`, `atuin init`, `mise activate`. These are portable (no absolute paths) and committed to git. Regenerate with the tool commands when versions change.

**Cached integrations** (`~/.cache/shell/`): Output of `starship init`, `direnv hook`. These contain absolute paths to binaries and must be regenerated per-machine via `bootstrap.sh`.

**Environment files** (`~/.config/shell/env.{fish,nu,zsh}`): Portable PATH setup with platform detection (`if test -d /nix`), EDITOR, SOPS secrets.

### Platform Setup

**nix-darwin:** `darwin-rebuild switch` installs packages and runs `bootstrap.sh` via activation script. Update packages: `cd ~/.config/nixos && nix flake update && darwin-rebuild switch --flake .`

**NixOS:** `nixos-rebuild switch` installs packages and runs `bootstrap.sh` via activation script.

**Arch Linux:** `git clone <repo> ~/.config && bash ~/.config/hosts/arch/initialize.sh`

**macOS (Homebrew only):** `git clone <repo> ~/.config && bash ~/.config/hosts/macos-brew/initialize.sh`

### macOS GUI Apps

macOS-only apps (Hammerspoon, Karabiner-Elements) require parity between platforms:

| Concern | nix-darwin | macos-brew |
|---------|-----------|------------|
| Install | `homebrew.casks` in `default.nix` | `brew install --cask` in `initialize.sh` |
| Config | `~/.config/{hammerspoon,karabiner}/` (portable, in git) | Same |
| Symlink | activation script (`~/.hammerspoon` -> `~/.config/hammerspoon`) | `initialize.sh` |
| Auto-start | `launchd.agents` in `home.nix` | macOS Login Items (manual first launch) |

**Rule:** When adding a new macOS cask to `default.nix`, also add it to `hosts/macos-brew/initialize.sh`.

### Home Manager Activation Scripts

Activation scripts should be **minimal**. The only shell-related activation script is `shellBootstrap` which runs `bootstrap.sh`.

Other valid activation scripts: symlinks (hammerspoon), tool installation (claude, opencode), directory creation (karabiner).

## 4. Shell Prompt Configuration (Starship)

**Starship** is the prompt for all shells. Nix installs it, `bootstrap.sh` generates init scripts in `~/.cache/shell/`, user configures in `~/.config/starship.toml`.

## 5. Secret Management with SOPS

**Philosophy:** Decrypt secrets on-the-fly in memory using `sops -d`. Never write plaintext secrets to disk.

**Architecture:**
```
~/.config/nixos/secrets/*.yaml  (ENCRYPTED in git)
        ↓ sops -d (runtime, conditional)
    ENV vars in memory (never on disk)
```

**Age Private Key Location:** `~/.local/share/sops/age/keys.txt` (permissions: `600`)

**Portable detection** in env files:
```fish
# Only load if sops is installed AND secret file exists
if command -q sops; and test -f "$HOME/.config/nixos/secrets/gemini_api_key.yaml"
    set -gx GEMINI_API_KEY (sops -d ... | yq '.GEMINI_API_KEY' | string trim)
end
```

**Security Rules:**
- Encrypted secrets in git (`~/.config/nixos/secrets/*.yaml`)
- In-memory decryption only (`sops -d`)
- Age key outside git (`~/.local/share/`)
- NEVER use `sops-nix` with `path =` (creates plaintext files)

## 6. Per-Project Dev Environments

### mise (Language Version Manager)

**mise** manages programming language versions per-project. Installed system-wide via Nix/pacman, activated per-shell via `~/.config/shell/integrations/mise.{fish,nu,zsh,bash}`.

Usage: `mise use node@22` creates `.mise.toml` in the project directory.

### devenv + direnv (Nix-based environments)

Use `devenv` + `direnv` for project-scoped Nix environments with services (DBs, Redis).

**Project structure:**
```
~/projects/my-app/
├── devenv.nix          # Languages, packages, services
├── devenv.yaml         # Nix inputs
├── .envrc              # use devenv
├── .devenv/            # State - gitignored
└── .direnv/            # Cache - gitignored
```

**`.envrc`:** `use devenv`

**`.gitignore`:** Add `.devenv/` and `.direnv/`

## Appendix A: Anti-Hallucination Tools Comparison

Comparison of Goose Recipes, Claude Code Hooks, and OpenCode Plugins for LLM hallucination prevention.

### Ranking

1. **Claude Code Hooks (85/100)** - Best overall. Real-time interception at every agentic loop step. Unique: LLM-as-judge (`type: "prompt"`), agent verifier (`type: "agent"`), Stop hook blocks premature completion, `TaskCompleted` quality gates. 16+ lifecycle events.
2. **OpenCode Plugins (60/100)** - Best DX. JS/TS + Zod type safety, npm ecosystem, LSP diagnostics (real code intelligence). Missing: Stop hooks, LLM-as-judge.
3. **Goose Recipes (45/100)** - Best for final output. `json_schema` forces structured output, `retry` + shell `checks` for automatic retry, `temperature: 0.0`. Weakness: validates only at the END, not during execution.

### Key Capabilities Matrix

| Capability | Claude Hooks | OpenCode Plugins | Goose Recipes |
|---|:---:|:---:|:---:|
| Pre-tool interception | `PreToolUse` | `tool.execute.before` | - |
| Post-tool validation | `PostToolUse` | `tool.execute.after` | - |
| Block tool calls | `deny` + exit 2 | `throw Error` | - |
| Modify inputs in-flight | `updatedInput` | `output.args = ...` | - |
| Prevent premature stop | **`Stop` block** | - | - |
| LLM-as-judge | **`type: "prompt"`** | - | - |
| Agent verifier | **`type: "agent"`** | - | - |
| LSP code intelligence | - | **`lsp.client.diagnostics`** | - |
| Forced structured output | - | - | **`json_schema`** |
| Auto retry + validation | - | - | **`retry` + `checks`** |
| Temperature control | - | - | **`temperature`** |
| Task completion gate | **`TaskCompleted`** | - | - |
| Type-safe validation | - | **TS + Zod** | - |
| LLM portability | Claude only | Multi-provider | Any LLM |

### Defense-in-Depth Strategy

- **Layer 1 - Prevention (OpenCode agents):** `temperature: 0.0`, restricted `tools` per agent, strict instructions in agent prompts
- **Layer 2 - Detection (Hooks + OpenCode):** `PreToolUse`/`tool.execute.before` validate inputs, `type: "prompt"` LLM-as-judge, `type: "agent"` reads code to verify, LSP diagnostics
- **Layer 3 - Containment (Hooks):** `Stop` hook blocks until criteria met, `TaskCompleted` quality gate, `PostToolUse` corrective feedback
- **Layer 4 - Recovery (OpenCode plugins):** retry-gate.ts tracks failures and forces review, scaffold-validator.ts verifies structure, test-gate.ts ensures non-trivial tests

### Decision Guide

- **Chosen workflow:** Claude Code (planning) → OpenCode (execution with plugins + agents + LSP)
- **Claude Code Hooks** apply when Claude Code itself is the executor (not delegating to OpenCode)
- **Goose Recipes** only for headless/unattended execution where no human supervises

## Appendix B: Cost-Optimized Project Execution Pattern

Strategy: use expensive LLM (Claude) once for planning, then execute with cheap/free LLMs guided by deterministic artifacts. Claude's intelligence crystallizes into artifacts (plugins + specs + rules), not consumed at execution time.

### Recommended Tool: OpenCode Only (interactive/supervised)

OpenCode wins as single tool because: hallucinations happen in **business logic** (HIGH risk), not scaffolding (LOW risk). OpenCode's unique strengths (real-time interception, LSP diagnostics, typed plugins, specialized agents) target the high-risk phase.

### Workflow

1. **Claude (one-time $$$):** Generate architecture, epics, hyper-specific stories, OpenCode plugins, rules, agents, and `opencode.json` config
2. **OpenCode + cheap LLM:** One session per story, agents define roles (scaffold/implement/review), plugins provide runtime guardrails, LSP provides deterministic code validation

### Project Structure

```
proyecto/
├── .plan/
│   ├── architecture.md
│   └── stories/E1-S1-*.md          # Hyper-specific specs (acceptance criteria, exact files, constraints)
├── .opencode/
│   ├── agents/                      # Specialized roles (md files with YAML frontmatter)
│   │   ├── scaffold.md              # Primary: creates structure only, no business logic
│   │   ├── implementer.md          # Primary: TDD implementation, invokes @reviewer
│   │   ├── reviewer.md             # Subagent: read-only code review, APPROVED/BLOCKED
│   │   └── tester.md               # Subagent: writes/validates tests only
│   ├── plugins/
│   │   ├── anti-hallucination.ts    # tool.execute.before: block out-of-scope writes, dangerous cmds
│   │   ├── retry-gate.ts           # tool.execute.after: track test failures, stop after N retries
│   │   ├── scaffold-validator.ts   # Custom tool: verify all expected files exist
│   │   └── test-gate.ts            # tool.execute.after: detect placeholders, trivial tests
│   ├── rules/
│   │   ├── scaffold.md              # Instructions for scaffold phase
│   │   └── story-flow.md           # Instructions for story implementation (TDD flow)
│   └── package.json                 # Plugin dependencies
└── opencode.json                    # Permissions (bash: ask, edit: allow), LSP config, agent overrides
```

### Agent Patterns (generated by Claude during planning)

Agents are `.md` files with YAML frontmatter. File name = agent name. `mode: primary` for Tab cycling, `mode: subagent` for `@mention` invocation.

- **scaffold.md:** `mode: primary`, cheap model (`gpt-5-mini`), `temperature: 0.0`, `edit: false` (only `write`), bash restricted to `mkdir/npm init/npm install`. Creates file stubs without business logic.
- **implementer.md:** `mode: primary`, capable model (`claude-sonnet-4.5`), `temperature: 0.0`, all tools enabled, bash `rm -rf: deny`, `permission.task: reviewer: allow`. Follows TDD flow, invokes `@reviewer` before committing.
- **reviewer.md:** `mode: subagent`, cheap model, `write: false`, `edit: false`, `bash: deny` (except `git diff/grep`), `steps: 5`. Read-only analysis, responds APPROVED or BLOCKED with reasons.
- **tester.md:** `mode: subagent`, `write: true`, `edit: true`, bash restricted to test runners (`npm test/jest`). Only writes test files.

### Plugin Patterns

- **anti-hallucination.ts:** `tool.execute.before` blocks writes outside story scope, dangerous bash patterns. `tool.execute.after` detects placeholders (`// ...`, `TODO: implement`, `Not implemented`)
- **retry-gate.ts:** `tool.execute.after` tracks test failures per command, throws error after 3 consecutive failures forcing the LLM to review
- **scaffold-validator.ts:** Custom tool with Zod schema that checks all expected files exist before proceeding to business logic
- **test-gate.ts:** `tool.execute.after` verifies test files are non-trivial (>5 lines) and contain real assertions

### Execution: One Session Per Story

Each story runs in a separate OpenCode session to ensure: fresh context (no contamination from previous stories), LSP re-analyzes current code, plugin state resets (retry counters, file scope), and failed stories don't affect committed work from previous ones.

### Keys for Success

- **Hyper-specific stories:** Exact acceptance criteria, exact file paths, exact constraints. Cheap LLMs need literal instructions
- **LSP configured:** Real compiler errors catch more than any LLM-based validator
- **One session per story:** Fresh context, clean plugin state, committed previous work
- **Plugins over prompts:** Deterministic code catches hallucinations; prompt-based rules get ignored by cheap LLMs

## Appendix C: Claude Code as Orchestrator Pattern

Use Claude Code as architect/orchestrator that dispatches OpenCode workers in separate Terminal tabs. Claude Code never writes business logic — it plans, dispatches, monitors, and validates.

### Core Mechanism

```bash
# Launch OpenCode with a specific agent and task in a new Terminal.app tab
osascript -e '
tell application "Terminal"
    activate
    tell application "System Events" to keystroke "t" using command down
    delay 0.5
    do script "opencode --agent implementer --prompt \"Implement E1-S1 per .plan/stories/E1-S1.md\"" in front window
end tell'
```

### Workflow Patterns

**Sequential pipeline:** Claude Code checks `git log` for previous story commit → launches next story tab → waits → validates tests → launches next.

**Parallel epics:** Each epic runs in its own tab on a separate git branch (`epic/auth`, `epic/api`). No conflicts. Merge at the end.

**Post-session validation:** After each OpenCode tab finishes, Claude Code runs `git diff`, `npm test`, and `grep -r "TODO\|FIXME" src/` to verify quality before launching the next story.

**Corrective sessions:** If validation fails, Claude Code launches a new tab with a targeted fix prompt: `"Tests in tests/auth/reset.test.ts fail with [error]. Fix it."`

**Concurrency control:** Max 2-3 parallel tabs. Check with `pgrep -f "opencode" | wc -l` before launching.

### Pre-session Context

Claude Code writes a temp file with exact context, OpenCode reads it:

```bash
cat > /tmp/oc-session.md << 'EOF'
Story: E1-S3 Password Reset
Spec: .plan/stories/E1-S3.md
Allowed files: src/routes/auth/reset.ts, tests/auth/reset.test.ts
Dependency: E1-S1 login exists, reuse src/utils/jwt.ts
Flow: TDD (tests first)
EOF
```

### Architecture

```
Claude Code (orchestrator, expensive, one-time planning)
├── Generates: .plan/, plugins, rules, agents, opencode.json
├── Dispatches: Terminal tabs with --agent and --prompt flags
├── Monitors: git log, test results across branches
├── Validates: post-session diffs, placeholder detection
└── Corrects: launches fix tabs if validation fails

OpenCode Workers (cheap LLM, agent-specialized, plugin-guarded)
├── Tab 1 --agent scaffold: Create structure per architecture.md
├── Tab 2 --agent implementer: E1-S1 → @reviewer → commit
├── Tab 3 --agent implementer: E2-S1 → @reviewer → commit (parallel epic)
└── Tab 4 --agent implementer: Integration tests after merge
```

### Specialized Tab Types

| Phase | Agent | Prompt pattern | Purpose |
|---|---|---|---|
| Scaffold | `--agent scaffold` | `"Create base structure per architecture.md"` | File stubs, CRUDs, mock data |
| Story impl | `--agent implementer` | `"Implement E1-S1 per .plan/stories/E1-S1.md"` | Business logic with TDD, invokes `@reviewer` |
| Refactor | `--agent implementer` | `"Refactor src/routes/auth/ removing duplication"` | Post-epic cleanup |
| Integration | `--agent implementer` | `"Write integration tests for Epic 1"` | Cross-story validation |

### Agent Interaction Within Sessions

The implementer agent can invoke subagents during its session:
- `@reviewer` before committing: read-only review with APPROVED/BLOCKED response
- `@tester` for complex test scenarios: writes test files only, cannot modify source code
- Subagent results feed back to the implementer's context for corrections
