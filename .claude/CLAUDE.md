# Project Rules & Guidelines

This file consolidates all development rules and guidelines for project, incorporating standards from multiple sources including general development principles, project-specific patterns, Context7 libraries, and the comprehensive project structure documentation.

## IMPORTANT: Documentation and File Management Policy

**No Documentation Files:** Do NOT generate explanatory files, guides, tutorials, or any standalone documentation files (README.md, GUIDE.md, etc.).

**Documentation Location:** All documentation must be added as **short, clear, and concise appendices** exclusively in this file (`.claude/CLAUDE.md`).

**Documentation Style:** ALL documentation in this file MUST be **extremely short, clear, and concise**. Avoid verbosity, redundancy, or unnecessary explanations. Get to the point immediately.

**Temporary Files:** Any temporary files generated during development or testing **MUST be deleted** immediately after use.

## 1. Communication and Language

**Primary Language:** All communication with AI assistants will be exclusively in **Spanish**.

**Code and Comments:**

- Generated code will always be in **English**.
- Comments within the code will also be in **English**, facilitating universal understanding and maintenance.

## 2. Software Development Principles

Excellence in development is paramount. Therefore, I strictly adhere to:

**SOLID Principles:** To create robust, maintainable, and scalable software.

- **S**ingle Responsibility Principle
- **O**pen/Closed Principle
- **L**iskov Substitution Principle
- **I**nterface Segregation Principle
- **D**ependency Inversion Principle

**DRY (Don't Repeat Yourself) Principle:** To avoid redundancy and improve code efficiency and maintainability.

**Test-Driven Development (TDD):** Writing tests before functional code to ensure quality and expected behavior from the outset.

## 3. Portable Configuration Philosophy

**Core Philosophy:** `~/.config/` is a **portable git repo** that works on any platform (nix-darwin, NixOS, Arch Linux) without modification. Nix is responsible for **installing** packages only. All user configuration lives in `~/.config/` and is **platform-agnostic**.

### Directory Structure

```
~/.config/                              # Git repo (portable)
  shell/
    env.fish, env.nu, env.zsh           # Portable env (PATH with platform detection)
    bashrc, zshrc, bash_profile         # Symlinked to ~/ by bootstrap.sh
    integrations/                       # Git-tracked (portable, rarely change)
      zoxide.{fish,nu,zsh,bash}
      atuin.{fish,nu,zsh,bash}
      yazi.{fish,nu,zsh,bash}
      cldy.{fish,nu}
      mise.{fish,nu,zsh,bash}
    bootstrap.sh                        # Generates ~/.cache/shell/ + symlinks dotfiles
  hosts/                                # Non-Nix platform setup scripts
    arch/initialize.sh                  # pacman packages + bootstrap + tools
    macos-brew/initialize.sh            # brew packages + bootstrap + tools + macOS setup
  fish/config.fish                      # Sources from shell/
  nushell/config.nu                     # Sources from shell/
  nushell/env.nu                        # Real file, sources shell/env.nu
  nixos/                                # Nix configuration ONLY (nix-darwin + NixOS)
    flake.nix, hosts/, lib/, secrets/

~/.cache/shell/                         # Ephemeral, NOT in git (absolute paths)
  starship.{fish,nu,zsh,bash}           # Generated by bootstrap.sh
  direnv.{fish,zsh,bash}                # Generated by bootstrap.sh
```

### Rules

**Rule 1: `~/.config/nixos/`** - Nix/NixOS/nix-darwin `.nix` files and SOPS secrets ONLY.

**Rule 2: `~/.config/<app>/`** - User-editable app configuration. No Nix-generated files.

**Rule 3: `~/.*` Dotfiles** - User-managed (`.zshrc`, `.bashrc`). No Nix-generated files.

**Rule 4: `~/.cache/shell/`** - Ephemeral files with absolute system paths. Generated by `bootstrap.sh`, not tracked in git.

### Shell Integration Architecture

**Tracked integrations** (`~/.config/shell/integrations/`): Output of tools like `zoxide init`, `atuin init`, `mise activate`. These are portable (no absolute paths) and committed to git. Regenerate with the tool commands when versions change.

**Cached integrations** (`~/.cache/shell/`): Output of `starship init`, `direnv hook`. These contain absolute paths to binaries and must be regenerated per-machine via `bootstrap.sh`.

**Environment files** (`~/.config/shell/env.{fish,nu,zsh}`): Portable PATH setup with platform detection (`if test -d /nix`), EDITOR, SOPS secrets.

### Platform Setup

**nix-darwin:** `darwin-rebuild switch` installs packages and runs `bootstrap.sh` via activation script. Update packages: `cd ~/.config/nixos && nix flake update && darwin-rebuild switch --flake .`

**NixOS:** `nixos-rebuild switch` installs packages and runs `bootstrap.sh` via activation script.

**Arch Linux:** `git clone <repo> ~/.config && bash ~/.config/hosts/arch/initialize.sh`

**macOS (Homebrew only):** `git clone <repo> ~/.config && bash ~/.config/hosts/macos-brew/initialize.sh`

### macOS GUI Apps

macOS-only apps (Hammerspoon, Karabiner-Elements) require parity between platforms:

| Concern | nix-darwin | macos-brew |
|---------|-----------|------------|
| Install | `homebrew.casks` in `default.nix` | `brew install --cask` in `initialize.sh` |
| Config | `~/.config/{hammerspoon,karabiner}/` (portable, in git) | Same |
| Symlink | activation script (`~/.hammerspoon` -> `~/.config/hammerspoon`) | `initialize.sh` |
| Auto-start | `launchd.agents` in `home.nix` | macOS Login Items (manual first launch) |

**Rule:** When adding a new macOS cask to `default.nix`, also add it to `hosts/macos-brew/initialize.sh`.

### Home Manager Activation Scripts

Activation scripts should be **minimal**. The only shell-related activation script is `shellBootstrap` which runs `bootstrap.sh`.

Other valid activation scripts: symlinks (hammerspoon), tool installation (claude, opencode), directory creation (karabiner).

## 4. Shell Prompt Configuration (Starship)

**Starship** is the prompt for all shells. Nix installs it, `bootstrap.sh` generates init scripts in `~/.cache/shell/`, user configures in `~/.config/starship.toml`.

## 5. Secret Management with SOPS

**Philosophy:** Decrypt secrets on-the-fly in memory using `sops -d`. Never write plaintext secrets to disk.

**Architecture:**
```
~/.config/nixos/secrets/*.yaml  (ENCRYPTED in git)
        ↓ sops -d (runtime, conditional)
    ENV vars in memory (never on disk)
```

**Age Private Key Location:** `~/.local/share/sops/age/keys.txt` (permissions: `600`)

**Portable detection** in env files:
```fish
# Only load if sops is installed AND secret file exists
if command -q sops; and test -f "$HOME/.config/nixos/secrets/gemini_api_key.yaml"
    set -gx GEMINI_API_KEY (sops -d ... | yq '.GEMINI_API_KEY' | string trim)
end
```

**Security Rules:**
- Encrypted secrets in git (`~/.config/nixos/secrets/*.yaml`)
- In-memory decryption only (`sops -d`)
- Age key outside git (`~/.local/share/`)
- NEVER use `sops-nix` with `path =` (creates plaintext files)

## 6. Per-Project Dev Environments

### mise (Language Version Manager)

**mise** manages programming language versions per-project. Installed system-wide via Nix/pacman, activated per-shell via `~/.config/shell/integrations/mise.{fish,nu,zsh,bash}`.

Usage: `mise use node@22` creates `.mise.toml` in the project directory.

### devenv + direnv (Nix-based environments)

Use `devenv` + `direnv` for project-scoped Nix environments with services (DBs, Redis).

**Project structure:**
```
~/projects/my-app/
├── devenv.nix          # Languages, packages, services
├── devenv.yaml         # Nix inputs
├── .envrc              # use devenv
├── .devenv/            # State - gitignored
└── .direnv/            # Cache - gitignored
```

**`.envrc`:** `use devenv`

**`.gitignore`:** Add `.devenv/` and `.direnv/`

## Appendix A: Anti-Hallucination Tools Comparison

Comparison of Goose Recipes, Claude Code Hooks, and OpenCode Plugins for LLM hallucination prevention.

### Ranking

1. **Claude Code Hooks (85/100)** - Best overall. Real-time interception at every agentic loop step. Unique: LLM-as-judge (`type: "prompt"`), agent verifier (`type: "agent"`), Stop hook blocks premature completion, `TaskCompleted` quality gates. 16+ lifecycle events.
2. **OpenCode Plugins (60/100)** - Best DX. JS/TS + Zod type safety, npm ecosystem, LSP diagnostics (real code intelligence). Missing: Stop hooks, LLM-as-judge.
3. **Goose Recipes (45/100)** - Best for final output. `json_schema` forces structured output, `retry` + shell `checks` for automatic retry, `temperature: 0.0`. Weakness: validates only at the END, not during execution.

### Key Capabilities Matrix

| Capability | Claude Hooks | OpenCode Plugins | Goose Recipes |
|---|:---:|:---:|:---:|
| Pre-tool interception | `PreToolUse` | `tool.execute.before` | - |
| Post-tool validation | `PostToolUse` | `tool.execute.after` | - |
| Block tool calls | `deny` + exit 2 | `throw Error` | - |
| Modify inputs in-flight | `updatedInput` | `output.args = ...` | - |
| Prevent premature stop | **`Stop` block** | - | - |
| LLM-as-judge | **`type: "prompt"`** | - | - |
| Agent verifier | **`type: "agent"`** | - | - |
| LSP code intelligence | - | **`lsp.client.diagnostics`** | - |
| Forced structured output | - | - | **`json_schema`** |
| Auto retry + validation | - | - | **`retry` + `checks`** |
| Temperature control | - | - | **`temperature`** |
| Task completion gate | **`TaskCompleted`** | - | - |
| Type-safe validation | - | **TS + Zod** | - |
| LLM portability | Claude only | Multi-provider | Any LLM |

### Defense-in-Depth Strategy

- **Layer 1 - Prevention (Goose):** `temperature: 0.0`, restricted `available_tools`, strict instructions
- **Layer 2 - Detection (Hooks + OpenCode):** `PreToolUse`/`tool.execute.before` validate inputs, `type: "prompt"` LLM-as-judge, `type: "agent"` reads code to verify, LSP diagnostics
- **Layer 3 - Containment (Hooks):** `Stop` hook blocks until criteria met, `TaskCompleted` quality gate, `PostToolUse` corrective feedback
- **Layer 4 - Recovery (Goose):** `json_schema` validates final structure, `retry` + `checks` retries on failure, `on_failure` cleanup

### Decision Guide

- **Need real-time control?** -> Claude Code Hooks
- **Need multi-LLM portability + type safety?** -> OpenCode Plugins
- **Need guaranteed final output structure?** -> Goose Recipes

## Appendix B: Cost-Optimized Project Execution Pattern

Strategy: use expensive LLM (Claude) once for planning, then execute with cheap/free LLMs guided by deterministic artifacts. Claude's intelligence crystallizes into artifacts (plugins + specs + rules), not consumed at execution time.

### Recommended Tool: OpenCode Only (interactive/supervised)

OpenCode wins as single tool because: hallucinations happen in **business logic** (HIGH risk), not scaffolding (LOW risk). OpenCode's unique strengths (real-time interception, LSP diagnostics, typed plugins) target the high-risk phase. Goose's unique strengths (retry, json_schema, temperature) target the low-risk phase.

**Exception:** Use Goose only for **headless/unattended** execution (overnight builds, scheduled runs) where retry + checks + json_schema provide autonomous resilience.

### Workflow

1. **Claude (one-time $$$):** Generate architecture, epics, hyper-specific stories, OpenCode plugins, rules, and `opencode.json` config
2. **OpenCode + cheap LLM:** One session per story, plugins provide runtime guardrails, LSP provides deterministic code validation

### Project Structure

```
proyecto/
├── .plan/
│   ├── architecture.md
│   └── stories/E1-S1-*.md          # Hyper-specific specs (acceptance criteria, exact files, constraints)
├── .opencode/
│   ├── plugins/
│   │   ├── anti-hallucination.ts    # tool.execute.before: block out-of-scope writes, dangerous cmds
│   │   ├── retry-gate.ts           # tool.execute.after: track test failures, stop after N retries
│   │   ├── scaffold-validator.ts   # Custom tool: verify all expected files exist
│   │   └── test-gate.ts            # tool.execute.after: detect placeholders, trivial tests
│   ├── rules/
│   │   ├── scaffold.md              # Instructions for scaffold phase
│   │   └── story-flow.md           # Instructions for story implementation (TDD flow)
│   └── package.json                 # Plugin dependencies
├── opencode.json                    # Permissions (bash: ask, edit: allow), LSP config
└── goose/                           # ONLY if headless execution needed
    ├── recipe.yaml                  # Orchestrator for unattended runs
    └── subrecipes/E1-S1-*.yaml
```

### Plugin Patterns (replicate Goose strengths in OpenCode)

- **anti-hallucination.ts:** `tool.execute.before` blocks writes outside story scope, dangerous bash patterns. `tool.execute.after` detects placeholders (`// ...`, `TODO: implement`, `Not implemented`)
- **retry-gate.ts:** `tool.execute.after` tracks test failures per command, throws error after 3 consecutive failures forcing the LLM to review
- **scaffold-validator.ts:** Custom tool with Zod schema that checks all expected files exist before proceeding to business logic
- **test-gate.ts:** `tool.execute.after` verifies test files are non-trivial (>5 lines) and contain real assertions

### Execution: One Session Per Story

Each story runs in a separate OpenCode session to ensure: fresh context (no contamination from previous stories), LSP re-analyzes current code, plugin state resets (retry counters, file scope), and failed stories don't affect committed work from previous ones.

### Why Not Both Tools

Running OpenCode + Goose simultaneously wastes ~70% extra tokens (idle context while the other tool runs). Running them sequentially adds operational complexity for marginal gain. OpenCode plugins can replicate Goose's retry logic and scaffold validation. The only thing OpenCode cannot replicate is Goose's headless autonomous execution with built-in retry.

### Keys for Success

- **Hyper-specific stories:** Exact acceptance criteria, exact file paths, exact constraints. Cheap LLMs need literal instructions
- **LSP configured:** Real compiler errors catch more than any LLM-based validator
- **One session per story:** Fresh context, clean plugin state, committed previous work
- **Plugins over prompts:** Deterministic code catches hallucinations; prompt-based rules get ignored by cheap LLMs

## Appendix C: Claude Code as Orchestrator Pattern

Use Claude Code as architect/orchestrator that dispatches OpenCode workers in separate Terminal tabs. Claude Code never writes business logic — it plans, dispatches, monitors, and validates.

### Core Mechanism

```bash
# Launch OpenCode in a new Terminal.app tab with a specific task
osascript -e '
tell application "Terminal"
    activate
    tell application "System Events" to keystroke "t" using command down
    delay 0.5
    do script "opencode --prompt \"Implement E1-S1 per .plan/stories/E1-S1.md\"" in front window
end tell'
```

### Workflow Patterns

**Sequential pipeline:** Claude Code checks `git log` for previous story commit → launches next story tab → waits → validates tests → launches next.

**Parallel epics:** Each epic runs in its own tab on a separate git branch (`epic/auth`, `epic/api`). No conflicts. Merge at the end.

**Post-session validation:** After each OpenCode tab finishes, Claude Code runs `git diff`, `npm test`, and `grep -r "TODO\|FIXME" src/` to verify quality before launching the next story.

**Corrective sessions:** If validation fails, Claude Code launches a new tab with a targeted fix prompt: `"Tests in tests/auth/reset.test.ts fail with [error]. Fix it."`

**Concurrency control:** Max 2-3 parallel tabs. Check with `pgrep -f "opencode" | wc -l` before launching.

### Pre-session Context

Claude Code writes a temp file with exact context, OpenCode reads it:

```bash
cat > /tmp/oc-session.md << 'EOF'
Story: E1-S3 Password Reset
Spec: .plan/stories/E1-S3.md
Allowed files: src/routes/auth/reset.ts, tests/auth/reset.test.ts
Dependency: E1-S1 login exists, reuse src/utils/jwt.ts
Flow: TDD (tests first)
EOF
```

### Architecture

```
Claude Code (orchestrator, expensive, one-time planning)
├── Generates: .plan/, plugins, rules, opencode.json
├── Dispatches: Terminal tabs with OpenCode sessions
├── Monitors: git log, test results across branches
├── Validates: post-session diffs, placeholder detection
└── Corrects: launches fix tabs if validation fails

OpenCode Workers (cheap LLM, plugin-guarded, one session per story)
├── Tab 1 (epic/auth): E1-S1 → commit → E1-S2 → commit
├── Tab 2 (epic/api):  E2-S1 → commit → E2-S2 → commit
└── Tab 3 (merge): Integration tests after merge
```

### Specialized Tab Types

| Phase | Prompt pattern | Purpose |
|---|---|---|
| Scaffold | `"Create base structure per architecture.md"` | File stubs, CRUDs, mock data |
| Story impl | `"Implement E1-S1 per .plan/stories/E1-S1.md"` | Business logic with TDD |
| Refactor | `"Refactor src/routes/auth/ removing duplication"` | Post-epic cleanup |
| Integration | `"Write integration tests for Epic 1"` | Cross-story validation |
